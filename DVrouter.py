####################################################
# DVrouter.py
# Name:Ngô Anh Tú
# HUID:23021702
#####################################################

from router import Router
from packet import Packet
from collections import defaultdict
import json

class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        
        self.distance_vector = defaultdict(lambda: float('inf'))  # Distance to each router
        self.distance_vector[addr] = 0  # Distance to self is 0
        self.forwarding_table = {}
        self.neighbor_vectors = {}  # addr -> vector
        self.neighbor_costs = {}    # port -> (neighbor, cost)
        self.port_to_neighbor = {}  # port -> neighbor

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            
            dst = packet.dst_addr
            if dst in self.forwarding_table:
                next_hop = self.forwarding_table[dst]
                for p, n in self.port_to_neighbor.items():
                    if n == next_hop:
                        self.send(p, packet)
                        break
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors
            
            # Routing packet
            sender = packet.src_addr
            vector = json.loads(packet.content)
            self.neighbor_vectors[sender] = vector
            updated = self.recompute_routing_table()
            if updated:
                self.broadcast_distance_vector()

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        
        self.port_to_neighbor[port] = endpoint
        self.neighbor_costs[endpoint] = cost

        # Add direct link to distance vector
        self.distance_vector[endpoint] = cost
        self.forwarding_table[endpoint] = endpoint

        # Initialize empty vector if not yet
        if endpoint not in self.neighbor_vectors:
            self.neighbor_vectors[endpoint] = {}

        self.broadcast_distance_vector()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        
        if port in self.port_to_neighbor:
            neighbor = self.port_to_neighbor[port]
            del self.port_to_neighbor[port]
            if neighbor in self.neighbor_costs:
                del self.neighbor_costs[neighbor]
            if neighbor in self.neighbor_vectors:
                del self.neighbor_vectors[neighbor]

            # Remove routes that use this neighbor as next hop
            to_remove = [dest for dest, nh in self.forwarding_table.items() if nh == neighbor]
            for dest in to_remove:
                if dest in self.distance_vector:
                    del self.distance_vector[dest]
                del self.forwarding_table[dest]

            updated = self.recompute_routing_table()
            if updated:
                self.broadcast_distance_vector()

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            
            self.broadcast_distance_vector()

    def broadcast_distance_vector(self):
        """Broadcast the distance vector to neighbors."""
        content = json.dumps(dict(self.distance_vector))
        for port in self.links:
            neighbor = self.links[port].e2
            packet = Packet(Packet.ROUTING, self.addr, neighbor, content)
            self.send(port, packet)

    def recompute_routing_table(self):
        updated = False
        new_dv = defaultdict(lambda: float('inf'))
        new_dv[self.addr] = 0
        new_ft = {}

        all_dests = set([self.addr]) | set(self.distance_vector.keys())
        for vec in self.neighbor_vectors.values():
            all_dests.update(vec.keys())

        for dest in all_dests:
            if dest == self.addr:
                continue
            min_cost = float('inf')
            best_next_hop = None
            for neighbor, cost_to_neighbor in self.neighbor_costs.items():
                neighbor_vector = self.neighbor_vectors.get(neighbor, {})
                cost_from_neighbor = neighbor_vector.get(dest, float('inf'))
                total_cost = cost_to_neighbor + cost_from_neighbor
                if total_cost < min_cost:
                    min_cost = total_cost
                    best_next_hop = neighbor
            # Also check if we have a direct link
            if dest in self.neighbor_costs and self.neighbor_costs[dest] < min_cost:
                min_cost = self.neighbor_costs[dest]
                best_next_hop = dest

            if min_cost < float('inf'):
                new_dv[dest] = min_cost
                new_ft[dest] = best_next_hop

        if dict(new_dv) != dict(self.distance_vector):
            self.distance_vector = new_dv
            self.forwarding_table = new_ft
            updated = True
        return updated
    
    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded

        return f"DVrouter(addr={self.addr}, dv={dict(self.distance_vector)}, ft={self.forwarding_table})"
        
